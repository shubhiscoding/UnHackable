name: CD Pipeline - UnHackable

on:
  # Triggered after CI completes successfully
  workflow_run:
    workflows: ["CI Pipeline - UnHackable"]
    types:
      - completed
    branches: [main, master]
  # Manual trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/unhackable

jobs:
  # ============================================
  # Stage 0: Deploy to Local Kubernetes
  # WHY: Automatic deployment to local development cluster
  #      via self-hosted runner for quick iteration
  # ============================================
  deploy-local:
    name: ðŸ  Deploy to Local Kubernetes
    runs-on: [self-hosted, local-k8s]
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify kubectl access
        run: |
          kubectl version --client
          kubectl cluster-info
          kubectl config current-context

      - name: Build Docker image locally
        run: |
          echo "Building Docker image: unhackable:${{ github.sha }}"
          docker build -t unhackable:${{ github.sha }} -f dockerfile .
          docker tag unhackable:${{ github.sha }} unhackable:latest

      - name: Create namespace
        run: kubectl create namespace local --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update secrets
        run: |
          if [ -f ".env.local" ]; then
            export $(cat .env.local | grep -v '^#' | xargs)
          fi
          kubectl create secret generic unhackable-secrets \
            --from-literal=DATABASE_URI="${DATABASE_URI:-mongodb://demo:demo@localhost:27017/unhackable}" \
            --from-literal=NEXT_PUBLIC_RPC_URL="${NEXT_PUBLIC_RPC_URL:-https://demo-rpc.example.com}" \
            --from-literal=GOOGLE_CLIENT_ID="${GOOGLE_CLIENT_ID:-demo-client-id}" \
            --from-literal=GOOGLE_CLIENT_SECRET="${GOOGLE_CLIENT_SECRET:-demo-secret}" \
            --from-literal=AUTH_SECRET="${AUTH_SECRET:-demo-auth-secret-$(openssl rand -hex 16)}" \
            --from-literal=NEXTAUTH_URL="${NEXTAUTH_URL:-http://localhost:3000}" \
            -n local --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to Kubernetes
        run: |
          sed "s|IMAGE_PLACEHOLDER|unhackable:${{ github.sha }}|g" k8s/deployment.yaml | \
          sed 's|imagePullPolicy: IfNotPresent|imagePullPolicy: Never|g' > /tmp/deployment-local.yaml
          kubectl apply -f /tmp/deployment-local.yaml -n local
          kubectl apply -f k8s/service.yaml -n local

      - name: Wait for rollout
        run: kubectl rollout status deployment/unhackable -n local --timeout=300s

      - name: Display deployment info
        run: |
          echo "âœ… Local deployment complete!"
          echo ""
          kubectl get pods -n local -l app=unhackable
          echo ""
          kubectl get svc -n local -l app=unhackable
          echo ""
          echo "ðŸ”— Access: http://localhost"

  # ============================================
  # Stage 1: Deploy to Staging (Kubernetes)
  # WHY: Validates deployment in non-production environment,
  #      allows testing before production release
  # ============================================
  # ============================================
  # Stage 1: Deploy to Staging (Kubernetes)
  # WHY: Validates deployment in non-production environment,
  #      allows testing before production release
  # ============================================
  deploy-staging:
    name: ðŸš€ Deploy to Staging
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config

      - name: Create namespace if not exists
        run: kubectl create namespace staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update secrets
        run: |
          kubectl create secret generic unhackable-secrets \
            --from-literal=DATABASE_URI="${{ secrets.DATABASE_URI }}" \
            --from-literal=NEXT_PUBLIC_RPC_URL="${{ secrets.NEXT_PUBLIC_RPC_URL }}" \
            --from-literal=GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}" \
            --from-literal=GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}" \
            --from-literal=AUTH_SECRET="${{ secrets.AUTH_SECRET }}" \
            --from-literal=NEXTAUTH_URL="${{ secrets.STAGING_URL }}" \
            -n staging --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to Kubernetes
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ env.IMAGE_NAME }}:${{ github.sha }}|g" k8s/deployment.yaml
          kubectl apply -f k8s/deployment.yaml -n staging
          kubectl apply -f k8s/service.yaml -n staging

      - name: Wait for rollout
        run: kubectl rollout status deployment/unhackable -n staging --timeout=300s

      - name: Deployment ready
        run: |
          echo "âœ… Staging deployment complete!"
          kubectl get pods -n staging -l app=unhackable

  # ============================================
  # Stage 2: DAST - Dynamic Application Security Testing
  # WHY: Tests running application for vulnerabilities,
  #      identifies runtime security issues
  # ============================================
  dast:
    name: ðŸ” DAST - Security Scan
    runs-on: ubuntu-latest
    needs: deploy-staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Run container locally for DAST scan
      - name: Start application for DAST
        run: |
          docker pull ${{ env.IMAGE_NAME }}:latest || echo "Using local build"
          docker run -d --name dast-target -p 3000:3000 \
            -e DATABASE_URI="${{ secrets.DATABASE_URI }}" \
            -e NEXT_PUBLIC_RPC_URL="${{ secrets.NEXT_PUBLIC_RPC_URL }}" \
            -e GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}" \
            -e GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}" \
            -e AUTH_SECRET="${{ secrets.AUTH_SECRET }}" \
            -e NEXTAUTH_URL="http://localhost:3000" \
            ${{ env.IMAGE_NAME }}:latest || \
            echo "âš ï¸ Could not pull image, skipping DAST"
          sleep 15

      # OWASP ZAP Baseline Scan (lightweight scan)
      - name: OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.12.0
        if: success()
        continue-on-error: true
        with:
          target: 'http://localhost:3000'
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a -j'

      - name: Upload DAST Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dast-report
          path: report_html.html
          retention-days: 7

      - name: Cleanup
        if: always()
        run: docker rm -f dast-target || true

  # ============================================
  # Stage 3: Deploy to Production
  # WHY: Final deployment after security validation,
  #      requires manual approval for safety
  # ============================================
  deploy-production:
    name: ðŸš€ Deploy to Production
    runs-on: ubuntu-latest
    needs: dast
    environment: production  # Requires manual approval in GitHub
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config

      - name: Create namespace if not exists
        run: kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -

      - name: Create/Update secrets
        run: |
          kubectl create secret generic unhackable-secrets \
            --from-literal=DATABASE_URI="${{ secrets.DATABASE_URI }}" \
            --from-literal=NEXT_PUBLIC_RPC_URL="${{ secrets.NEXT_PUBLIC_RPC_URL }}" \
            --from-literal=GOOGLE_CLIENT_ID="${{ secrets.GOOGLE_CLIENT_ID }}" \
            --from-literal=GOOGLE_CLIENT_SECRET="${{ secrets.GOOGLE_CLIENT_SECRET }}" \
            --from-literal=AUTH_SECRET="${{ secrets.AUTH_SECRET }}" \
            --from-literal=NEXTAUTH_URL="${{ secrets.PRODUCTION_URL }}" \
            -n production --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy to Kubernetes
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ env.IMAGE_NAME }}:${{ github.sha }}|g" k8s/deployment.yaml
          kubectl apply -f k8s/deployment.yaml -n production
          kubectl apply -f k8s/service.yaml -n production

      - name: Wait for rollout
        run: kubectl rollout status deployment/unhackable -n production --timeout=300s

      - name: Verify deployment
        run: |
          echo "âœ… Production deployment complete!"
          echo ""
          echo "ðŸ“¦ Image: ${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "ðŸ”— Commit: ${{ github.sha }}"
          echo ""
          kubectl get pods -n production -l app=unhackable
          kubectl get svc -n production -l app=unhackable
